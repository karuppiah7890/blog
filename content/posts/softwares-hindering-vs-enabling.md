---
title: "Softwares: Hindering vs Enabling"
date: 2020-10-06T22:29:23+05:30
---

## TLDR;

"It's not built for this thing"

"It's not supposed to be done this way"

"It has a bug. This is not expected!"

"It's too rigid, not flexible or configurable"

"It does not have the feature that you want"

"You are expecting it to do too much. It's not supposed to be doing that much
maybe"

"Some evil corporation's mission is to hinder you. Just kidding. Dig deep.
Understand the core of the problem"

## Full version

In today's Software Development world, almost everyone relies on existing
software to build their core software or to make their life easier. In this
post, when I say software, I'm referring to any software - tools, libraries,
frameworks, web apps, web services, desktop apps, mobile apps, and almost any
software that you can find under the sun when it comes to the software
development industry. Basically anything that has "features". I would consider
any technology in general and even programming languages - they are languages
yes, but they only existent because there's an interpreter or compiler or some
tool to understand them and convert them to something that can run.

Have you ever felt that sometimes the softwares you use are hindering you and
not enabling you? Have you ever wondered why that's the case?

I have noticed in my case that sometimes, the softwares I use are not helping
me. I even get frustrated thinking how the software should enable me. Upon wondering how to go about understanding the core of the problem, I thought about a few points that made sense to me:

- Every software is created for some particular purpose(s) / use case(s)
- Knowledge and experience with the software is important to be able to use the software
  the right way

I feel that sometimes we make the mistake of choosing the wrong software for
our job and hence face the issues of the software hindering us. It's pretty
important to understand the problem(s) and use case(s) the software was built
for. Whenever you choose a software, be sure to understand the software's "Why?
", that is "Why does this software exist? What problem(s) does it solve? How
does it solve it? What are some example use case(s)?". Usually the software's
resources - website, homepage, docs etc should give out this information. It's
important to understand your software in this aspect before choosing it.

Even if one has chosen the right software for the right job, it's sometimes possible that the software is hindering the user. Why would that be the case? It's possible the user is using the software in a way that it wasn't intended to. Every software has been built to be used in a particular way for solving a particular set of problems. Ideally, the creator(s) of the software should have created the software intuitively, to make sure that the user always uses it the right way, and also make sure that it's hard or impossible to use it the wrong way by having some restrictions or hardships. But this is not very easily possible in all softwares - usually it's very easy to restrict in GUI softwares, but not very easy to make things very clear to the user on how to use it the right way when it comes to programming languages, libraries, frameworks, and maybe many other softwares that I don't know of.

No wonder there are a lot of tutorials on "best practices", again, based on
some use cases and goals. Softwares do help sometimes by hinting to the user
with a warning that something doesn't seem right, and sometimes with errors
too. Erros are the best :) But warnings, when users see warnings, they just
ignore it as it doesn't stop them or block them from doing their work. So it
just goes unnoticed, and whatever the user built with the software now has
problems that they ignored, which may bubble up later as bigger issues.

So it's clearly very important to use the software in an appropriate way or
else it's not going to give you the best results as the creators may have not
built it for using it the way you are using it. To give an example, I have seen
such cases when people complain about performance issues - when using different
softwares, or even programming languages. It's rarely the case that the
software or the programming language has it's limits, sometimes it's just that
the developer didn't use it the way it's intended to be used. To be sure about
what's the real problem, you will have to always dig deep, and understand the
truth.

Now, let's just say that the tool is right for the job and it's also being used
the right way, but the software is still hindering the user. Some of the
possible issues that I have noticed in this case are - the software is not very
flexible / configurable, the software does not have the feature that the user
desperately needs and it's a deal breaker to move to another software, or the
software just has some bug(s). These are just the cases that I have noticed,
may be there are more!

Also, one thing to note is, sometimes it's also a design problem - where the
user is expecting too much from the software - for it to be able to do many
things. Sometimes you can just use another software to do another thing instead
of having a one stop shop for everything and expecting your software to just
have every feature you want. It really depends on the context, but it's a
notable thing. Maybe you just need another extra software which can augment the
current ones and not replace them to provide you everything at once. Maybe.

As you can see, if you are facing a problem with your software, and you feel
it's hindering you, there might be many reasons to it ðŸ˜… If you really want to
solve the problem, you will have to dig deep and understand the problem and
consider some of the factors I just mentioned above - for which you need to
really do your research, which is key.

In my experience as 3 years as a Software Developer, I have noticed that a lot
of times, it's just my fault when it comes to software being an hindrance -
either I didn't choose the right software for the job, or I just didn't use it
the right way ðŸ˜… :P I have found a few bugs too, but they always got fixed
soon, so it was an easy thing :)
